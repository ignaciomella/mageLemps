<?php
/**
 * Hyvä Themes - https://hyva.io
 * Copyright © Hyvä Themes 2020-present. All rights reserved.
 * This product is licensed per Magento install
 * See https://hyva.io/license
 */

declare(strict_types=1);

use Hyva\Theme\ViewModel\Modal;
use Magento\Framework\Escaper;
use Magento\Framework\View\Element\Template;

// phpcs:disable Generic.Files.LineLength.TooLong

/** @var Template $block */
/** @var Escaper $escaper */

?>
<script>
    'use strict';

    (function () {
        const modals = [];
        const excludedFromFocusTrapping = new Set();

        function loadInertPolyfill(callback) {
            // undocumented "feature", should not be used unless inert attribute support is guaranteed
            if (window.hyva.modal.disableInertPolyfill) {
                callback && callback();
            } else {
                const polyfill = document.createElement('script');
                polyfill.src = '<?= $escaper->escapeJs($escaper->escapeUrl($block->getViewFileUrl('Hyva_Theme/js/wicg-inert-3.1.1/inert.min.js'))) ?>';
                callback && polyfill.addEventListener('load', callback);
                const firstScriptTag = document.getElementsByTagName('script')[0];
                firstScriptTag.parentNode.insertBefore(polyfill, firstScriptTag);
            }
        }

        let isInertPolyfillLoaded = 0;
        function setSiblingsInert(dialogElement, toState) {
            if (isInertPolyfillLoaded === 0) {
                isInertPolyfillLoaded = 1;
                loadInertPolyfill(() => {
                    isInertPolyfillLoaded = 2;
                    setSiblingsInert(dialogElement, toState)
                })
                return;
            }
            if (isInertPolyfillLoaded === 1) {
                return;
            }
            // Walk up the DOM, toggle inert attribute the siblings at each level
            let el = dialogElement;
            while (el && (el = el.parentElement)) {
                if (el === document.body || el.parentElement === null) continue;

                Array.from(el.parentElement.children).forEach(sibling => {
                    if (sibling !== el) {
                        sibling.inert = toState;
                    }
                })
            }
            // Walk down the DOM, toggle inert attribute to opposite of toState.
            // This is needed if a nested dialog is rendered as a sibling of the opening dialog.
            (function setChildrenInert(el, toState) {
                if (el) {
                    el.inert = toState;
                    Array.from(el.children).forEach(child => setChildrenInert(child, toState));
                }
            })(findParentWithOverlaySpread(dialogElement), ! toState)

            excludedFromFocusTrapping.forEach(selector => {
                Array.from(document.querySelectorAll(selector)).map(el => el.inert = false);
            })
        }

        function findParentWithOverlaySpread(el) {
            while (el && (el = el.parentElement)) {
                if (el === document.body || el.parentElement === null) continue;
                if (el.hasAttribute('x-spread') && el.getAttribute('x-spread').indexOf('overlay(') !== -1) {
                    return el;
                }
            }
        }

        function freeFocusFromModalTrap(modal) {
            const dialogElement = modal.viewModel.$refs[modal.name];
            isOverlayDisabled(dialogElement) || modal.viewModel.$nextTick(() => setSiblingsInert(dialogElement, false));
        }

        function trapFocusInNextModalWithOverlay() {
            for (let idx = modals.length -1; idx >= 0; idx--) {
                const nextOnStack = modals[idx];
                const nextDialogElement = nextOnStack.viewModel.$refs[nextOnStack.name];
                if (! isOverlayDisabled(nextDialogElement)) {
                    nextOnStack.viewModel.$nextTick(() => setSiblingsInert(nextDialogElement, true));
                    break;
                }
            }
        }

        function focusables(dialogElement) {
            const selector = 'a, button, input, textarea, select, details, [tabindex]:not([tabindex="-1"])';
            return Array.from(dialogElement.querySelectorAll(selector))
                .filter(el => !el.hasAttribute('disabled'));
        }

        function firstVisible(elements) {
            const a = Array.from(elements);
            for (let i = 0; i < a.length; i++) {
                if (a[i].offsetWidth || a[i].offsetHeight || a[i].getClientRects().length) return a[i];
            }
            return null;
        }

        function isInViewport(element) {
            const rect = element && element.getBoundingClientRect();
            return rect &&
                rect.top >= 0 &&
                rect.left >= 0 &&
                rect.right <= window.innerWidth &&
                rect.bottom <= window.innerHeight;
        }

        function setFocusAfterTransition(dialogElement, duration) {
            window.setTimeout(() => {
                const focusElement = firstVisible(dialogElement.querySelectorAll('[x-focus-first]')) ||
                    focusables(dialogElement)[0] ||
                    null;
                focusElement && isInViewport(focusElement) && focusElement.focus();
            }, duration + 1);
        }

        function ucFirst(s) {
            return s.substr(0, 1).toUpperCase() + s.substr(1);
        }

        function isOpenProp(dialogName) {
            return 'is' + ucFirst(dialogName) + 'Open';
        }

        function determineTrigger($refs, dialog, trigger) {
            // if show() was called without arguments use the event target as open trigger
            if (typeof trigger === 'undefined' && typeof dialog === 'object' && dialog.target && dialog.target.focus) {
                return dialog.target;
            }
            // if show('name', $event) was called with the event as the second argument use the event target as trigger
            if (typeof dialog === 'string' && typeof trigger === 'object' && trigger.target && trigger.target.focus) {
                return trigger.target;
            }
            // if show('name', 'trigger') was called with the ref name of the trigger element use that as the trigger
            if (typeof trigger === 'string' && $refs[trigger]) {
                return $refs[trigger];
            } else {
                // unknown trigger - no focus will be set when the dialog is hidden.
                return null;
            }
        }

        function isOverlayDisabled(dialog) {
            return dialog && dialog.hasAttribute('x-no-overlay')
        }

        function areRemainingModalsWithoutOverlay(modals)
        {
            const overflowDisabled = modals.map(modal => modal.viewModel.$refs[modal.name]).filter(isOverlayDisabled);

            return overflowDisabled.length === modals.length;
        }

        window.hyva.modal = function(options) {

            const config = Object.assign({
                dialog: '<?= /* @noEscape */ Modal::DEFAULT_NAME ?>', // default dialog ref name
                duration: 300, // ms before allowing subsequent hiding of modals for nested modals (see transition duration)
                transitionEnter: 'transition ease-out duration-300',
                transitionEnterStart: 'opacity-0',
                transitionEnterEnd: 'opacity-100',
                transitionLeave: 'transition ease-in duration-300',
                transitionLeaveStart: 'opacity-100',
                transitionLeaveEnd: 'opacity-0',
            }, options);
            let lastHide = 0;

            return {
                show(dialog, trigger) {
                    const focusTargetAfterHide = determineTrigger(this.$refs, dialog, trigger);
                    const name = typeof dialog === 'string' ? dialog : config.dialog;
                    const dialogElement = this.$refs[name];
                    const useOverlay = ! dialogElement.hasAttribute('x-no-overlay');

                    dialogElement.scrollTop = 0;

                    // Prevent adding the same modal on the stack twice
                    if (this[isOpenProp(name)]) {
                        return;
                    }

                    this[isOpenProp(name)] = true;
                    useOverlay && this.$nextTick(() => setSiblingsInert(dialogElement, true));
                    setFocusAfterTransition(dialogElement, config.duration);

                    const frame = {name, viewModel: this, focusTarget: focusTargetAfterHide, time: Date.now()};

                    modals.push(frame);
                    if (useOverlay) {
                        document.body.classList.add('overflow-hidden');
                    }
                    return new Promise(resolve => frame.resolve = resolve);
                },
                cancel() {
                    this.hide(false);
                },
                ok() {
                    this.hide(true);
                },
                hide(value) {
                    // Guard against Escape being pressed multiple times before a transition is finished, otherwise
                    // this function will pop further dialogs from the stack but the display will not update.
                    if (Date.now() - lastHide < config.duration) {
                        return;
                    }
                    lastHide = Date.now();

                    const modal = modals.pop() || {};
                    const name = modal.name;
                    this[isOpenProp(name)] = false;

                    freeFocusFromModalTrap(modal)
                    trapFocusInNextModalWithOverlay();

                    const nextFocusAfterHide = modal.focusTarget;
                    nextFocusAfterHide && this.$nextTick(() => nextFocusAfterHide.focus());

                    if (modals.length === 0 || areRemainingModalsWithoutOverlay(modals)) {
                        document.body.classList.remove('overflow-hidden');
                    }

                    modal.resolve(value);
                },
                [isOpenProp(config.dialog)]: false,
                overlay(dialog) {
                    const name = typeof dialog === 'string' ? dialog : config.dialog;
                    return {
                        ['x-show']() {
                            return this[isOpenProp(name)];
                        },
                        ['x-transition:enter']: config.transitionEnter,
                        ['x-transition:enter-start']: config.transitionEnterStart,
                        ['x-transition:enter-end']: config.transitionEnterEnd,
                        ['x-transition:leave']: config.transitionLeave,
                        ['x-transition:leave-start']: config.transitionLeaveStart,
                        ['x-transition:leave-end']: config.transitionLeaveEnd,
                    };
                }
            };
        }

        window.hyva.modal.pop = function () {
            if (modals.length > 0) {
                const modal = modals[modals.length -1];
                modal.viewModel.hide();
            }
        }

        window.hyva.modal.excludeSelectorsFromFocusTrap = function (selectors) {
            typeof selectors === 'string' || selectors instanceof String
                ? excludedFromFocusTrapping.add(selector)
                : selectors.map(selector => excludedFromFocusTrapping.add(selector));
        }

        window.hyva.modal.eventListeners = {
            keydown: event => {
                if (event.key === 'Escape') {
                    window.hyva.modal.pop();
                }
            },
            // generic modal @click.away handler
            click: event => {
                if (modals.length > 0) {
                    const modal = modals[modals.length -1];
                    const dialog = modal.viewModel.$refs[modal.name];
                    if (modal.time + 10 < Date.now() && // if last click processing is more than 10ms ago
                        ! isOverlayDisabled(dialog) && // if dialog has overlay
                        ! dialog.contains(event.target)) { // if click is outside of dialog
                        modal.viewModel.hide();
                    }
                }
            }
        };

        document.addEventListener('keydown', window.hyva.modal.eventListeners.keydown);

        document.addEventListener('click', window.hyva.modal.eventListeners.click);
    })();
</script>
